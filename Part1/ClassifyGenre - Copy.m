song_path = '\data\classical\artist_2_album_1_track_1.wav';

%Software switch used to evaluate question 6, 7, 8 or neither
question6 = 1;
question7 = 1;
question8 = 1;

%{
-----------------------ATTRIBUTES OF ANALYSIS-----------------------
%}

%Frame size. Want a frame of size 512 for this part of the project
frameSize_N = 512;

%For 50 percent overlap, step_size should be half of the frame size
step_size = frameSize_N/2;

%number of seconds in two minutes
twoMinutes = 2*60;

%Create a window of size frameSize_N
w = hann(frameSize_N);


%{
-----------------------DEVELOP INFORMATION ABOUT SONG-----------------------
%}

%Read audio file and form audio object to easily collect data about song
[audio_data, Fs] = audioread(song_path);
songObject = audioplayer(audio_data,Fs);

%Maximum number of frame possible in these songs
maxNumFrames = 2*floor((songObject.SampleRate*twoMinutes)/frameSize_N)-1;

%By default make Nf the max number of frames to analyze in two minutes
numFrames_Nf = maxNumFrames;

%Note: sample index at T seconds = sample rate * T
songDuration = songObject.TotalSamples/songObject.SampleRate;


%{
-----------------------EXTRACT TWO MINUTES FROM SONG-----------------------
%}

if songDuration <= twoMinutes
    %Song is less than or is two minutes long. Use the whole song.
    
    %Determining the possible number of frames to extract. Subtracting 1 to
    %avoid overflow.
    numFrames_Nf = 2*floor(songObject.TotalSamples/frameSize_N)-1;

    %Analyze song from start to end
    startingIndexOfFirstFullFrame = 1;
    startingIndexOfLastFullFrame = numFrames_Nf*step_size;
    
else
    %Song is greater than two minutes.
    
    %Take two min of audio data from song_path starting from the middle
    
    %{
        Definitions of variables below:

        songObject - audio player object generated by slice_audio()
        fs = sampling rate of song
        start = frame at middle of song
        stop = end of two minute sample
    %}
      
    [songObject, wav, fs, start, stop] = slice_audio(song_path,twoMinutes,1);

    %Analyze song from start to beginning
    startingIndexOfFirstFullFrame = start;
    startingIndexOfLastFullFrame = numFrames_Nf*step_size;
end    

%Finding first nonzero sample of song (used for part 1)
%first_nonzero_index = min(find(wav ~= 0));

%increment starting frame number
 for frameStart = startingIndexOfFirstFullFrame:step_size:startingIndexOfLastFullFrame
    
    
    %Take difference between current and the very first frame index, divide
    %by step size, add 1 to avoid indexing 0
    frameNumber = ((frameStart-startingIndexOfFirstFullFrame)/step_size) + 1;

    %determine the end sample index
    frameEnd = frameStart + (frameSize_N-1);

    
    %Extract one frame
    xn = audiodata(frameStart:frameEnd);

    %Fourier transform of signal using hann window, w
    Y = fft(w.*xn);
    K = frameSize_N/2 + 1;
    Xn = Y(1:K);
    
    %Equation 21 from part II. Modified to retain only 12 bands, like with
    %the chroma
    
   %{
    -----------------------NEW FILTER BANK AND MFCC INFO-----------------------
    %} 
    t = zeros(1,36);
    t(1) =1;t(7:8)=5;t(15:18)= 9;
    t(2) = 2; t( 9:10) = 6; t(19:23) = 10;
    t(3:4) = 3; t(11:12) = 7; t(24:29) = 11;
    t(5:6) = 4; t(13:14) = 8; t(30:36) = 12;
    
    mel2 = zeros(12,size(mfcc,2));
    for i=1:12,
        mel2(i,:) = sum(mfcc(t==i,:),1);
    end
    
    mfcc = mel2;
    
    
    %{
    -----------------------4.7 COMPUTING DISTANCE BETWEEN FEATURES-----------------------
    Answers questions 6 and 7
    %} 
    
    %{
        In general, we are collapsing the information gathered about the
        songs, in previous section, into an average note, and a covariance
        matrix (telling us how much each element of the song is correlated to itself. - not a
        very good explanation of it...)
        
        Mean note of song used to categorize it
        mu = mean(mfcc,2);

        Covariance of song used to categorize it
        Cov = cov(mfcc);
    
        The Kullback-Leibler divergence is given in equation (23) on page
        20
    
        Computing this value will allow us to compute the distance between
        two songs.
        
    %}
    
    %Computing the distance d between the two tracks s1 and s2 
    
    %Going to include implementation of Professor Meyer's code here:
    
    m1 = mean(mfcc1,1);
    m2 = mean(mfcc2,2);
    
    Co1 = cov(mfcc1);
    Co2 = cov(mfcc2);
    
    iCo1 = inv(Co1);
    iCo2 = inv(Co2);
    KL = 0.5*(trace(Co1*iCo2) + trace(Co2*iCo1) + trace((iCo1+iCo2)*(m1-m2)*(m1-m2)));
    gam = 0.5;
    d = -exp(-KL/gam)
    
    %imagesc(d)
    colorbar;
    colormap('jet');
    
    
    %{
    -----------------------Compute the 6 x 6 average distance matrix between the genres-----------------------
    %} 
    genreDistance = zeros(6,6);
    
    for song1 = 1:6
        for song2 1:6          
            genreDistance(i,j) =  (1/(25^2))*songDistance(song1,song2);
        end
    end   
        
    
    
 end 